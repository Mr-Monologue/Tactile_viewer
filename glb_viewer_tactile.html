<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GLB + 虚拟触觉演示 (最终六角网格版)</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0b0b;
            color: #e2e8f0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto
        }

        #app {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-rows: auto 1fr auto
        }

        header {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 10px 12px;
            background: #0f1218;
            border-bottom: 1px solid #1e293b
        }

        header .brand {
            font-weight: 700;
            letter-spacing: .3px;
            color: #9bdcff
        }

        header .spacer {
            flex: 1
        }

        header .btn,
        label.btn {
            background: #121824;
            border: 1px solid #1f2a38;
            color: #d0e7ff;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer
        }

        header .btn:hover,
        label.btn:hover {
            border-color: #2b394f
        }

        #viewport {
            position: relative;
            overflow: hidden
        }

        #viewport canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #hud {
            display: flex;
            gap: 14px;
            align-items: center;
            justify-content: center;
            padding: 6px 10px;
            color: #94a3b8;
            background: #0f1218;
            border-top: 1px solid #1e293b;
            font-size: 13px
        }

        .num {
            color: #99e9ff
        }

        input[type=file] {
            display: none
        }

        .switch {
            display: inline-flex;
            align-items: center;
            gap: 6px
        }
    </style>

    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
      "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.0/build/index.module.js"
    }
  }
  </script>
</head>

<body>
    <div id="app">
        <header>
            <div class="brand">GLB + Tactile Demo</div>
            <label class="btn">选择GLB
                <input id="file" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" />
            </label>
            <button id="btnResample" class="btn">重新采样 (基于当前视角)</button>
            <button id="btnReset" class="btn">重置视角</button>
            <div class="spacer"></div>
            <label class="switch"><input id="chkAuto" type="checkbox" checked />自动旋转</label>
            <label class="switch"><input id="chkBg" type="checkbox" checked />暗色背景</label>
        </header>

        <div id="viewport"></div>

        <div id="hud">
            <span id="info">未加载模型</span>
            <span id="stats"></span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
        import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';
        import { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';
        import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
        import { acceleratedRaycast, computeBoundsTree, disposeBoundsTree } from 'three-mesh-bvh';

        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;

        const wrap = document.getElementById('viewport');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0b0b);
        const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 2000);
        camera.position.set(2.8, 1.6, 3.2);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        wrap.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const pmrem = new THREE.PMREMGenerator(renderer);
        scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
        scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 6, 8);
        scene.add(dirLight);
        const grid = new THREE.GridHelper(10, 10, 0x334155, 0x1f2937); grid.visible = false; scene.add(grid);

        const worldAxes = new THREE.AxesHelper(1.2);
        worldAxes.material.depthTest = false; worldAxes.renderOrder = 10;
        scene.add(worldAxes);

        class TactileLayer {
            constructor(parentMesh, options = {}) {
                this.mesh = parentMesh;
                this.spacing = options.spacing ?? 0.05;
                const maxPoints = options.maxPoints ?? 5000;

                this.attrCol = new THREE.BufferAttribute(new Float32Array(maxPoints * 3), 3);
                this.attrInt = new THREE.BufferAttribute(new Float32Array(maxPoints), 1);

                const diskPlane = new THREE.PlaneGeometry(1, 1);
                const diskVertex = `attribute float radius;attribute float intensity;attribute vec3 nrmW;uniform vec3 camRight;uniform vec3 camUp;uniform float pushW;varying vec2 vUv;varying vec3 vColor;void main(){vUv=uv;vColor=color;vec3 center=(instanceMatrix*vec4(0.,0.,0.,1.)).xyz+normalize(nrmW)*pushW;float R=radius*(1.+.9*intensity);vec2 quad=(uv-.5)*(2.*R);vec3 pos=center+camRight*quad.x+camUp*quad.y;gl_Position=projectionMatrix*viewMatrix*vec4(pos,1.);}`;
                const diskFragment = `varying vec2 vUv;varying vec3 vColor;void main(){vec2 p=vUv*2.-1.;if(dot(p,p)>1.)discard;gl_FragColor=vec4(vColor,1.);}`;
                this.matDisks = new THREE.ShaderMaterial({ vertexColors: !0, transparent: !1, depthTest: !0, depthWrite: !0, uniforms: { camRight: { value: new THREE.Vector3(1, 0, 0) }, camUp: { value: new THREE.Vector3(0, 1, 0) }, pushW: { value: 0 } }, vertexShader: diskVertex, fragmentShader: diskFragment });

                this.disks = new THREE.InstancedMesh(diskPlane, this.matDisks, maxPoints);
                this.disks.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const radiiArr = new Float32Array(maxPoints);
                const nrmArr = new Float32Array(maxPoints * 3);
                this.disks.geometry.setAttribute('radius', new THREE.InstancedBufferAttribute(radiiArr, 1));
                this.disks.geometry.setAttribute('intensity', new THREE.InstancedBufferAttribute(this.attrInt.array, 1));
                this.disks.geometry.setAttribute('nrmW', new THREE.InstancedBufferAttribute(nrmArr, 3));
                this.disks.geometry.setAttribute('color', new THREE.InstancedBufferAttribute(this.attrCol.array, 3));
                this.disks.renderOrder = 2;
                scene.add(this.disks);

                this.t = 0; this.running = true; this.finalPoints = [];
            }

            dispose() {
                scene.remove(this.disks);
                this.disks.geometry.dispose();
                this.matDisks.dispose();
            }

            async generateHexGrid(camera) {
                console.time('Hex Grid Generation');
                document.getElementById('info').textContent = '正在生成六角网格...';
                await new Promise(r => setTimeout(r, 20));

                this.mesh.updateWorldMatrix(true, true);
                const meshes = [];
                this.mesh.traverse(o => { if (o.isMesh && o.geometry?.attributes?.position) meshes.push(o); });
                if (!meshes.length) return;

                const geos = meshes.map(m => m.geometry.clone().applyMatrix4(m.matrixWorld));
                const merged = BufferGeometryUtils.mergeGeometries(geos, false);
                if (!merged) return;

                merged.computeBoundsTree();
                const targetMesh = new THREE.Mesh(merged);

                const verts = []; const norms = [];
                const posAttr = merged.getAttribute('position');
                const nrmAttr = merged.getAttribute('normal') || (merged.computeVertexNormals(), merged.getAttribute('normal'));
                const step = Math.max(1, Math.ceil(posAttr.count / 3000));
                for (let i = 0; i < posAttr.count; i += step) {
                    verts.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
                    norms.push(new THREE.Vector3().fromBufferAttribute(nrmAttr, i));
                }

                const center = verts.reduce((a, b) => a.add(b), new THREE.Vector3()).multiplyScalar(1 / verts.length);
                let normal = norms.reduce((a, b) => a.add(b), new THREE.Vector3()).normalize();
                if (normal.lengthSq() < 1e-6) normal.set(0, 0, 1);

                const toCam = camera.position.clone().sub(center).normalize();
                if (normal.dot(toCam) < 0) normal.multiplyScalar(-1);

                let U = new THREE.Vector3(1, 0, 0);
                if (Math.abs(normal.x) > 0.9) U.set(0, 1, 0);
                U.sub(normal.clone().multiplyScalar(U.dot(normal))).normalize();
                const V = new THREE.Vector3().crossVectors(normal, U).normalize();

                let umin = Infinity, umax = -Infinity, vmin = Infinity, vmax = -Infinity;
                verts.forEach(p => {
                    const d = p.clone().sub(center);
                    const u = d.dot(U); const v = d.dot(V);
                    if (u < umin) umin = u; if (u > umax) umax = u;
                    if (v < vmin) vmin = v; if (v > vmax) vmax = v;
                });

                const pad = this.spacing * 1.5;
                umin -= pad; umax += pad; vmin -= pad; vmax += pad;

                const du = this.spacing;
                const dv = this.spacing * Math.sqrt(3) * 0.5;

                const raycaster = new THREE.Raycaster();
                raycaster.firstHitOnly = true;

                const diag = new THREE.Box3().setFromObject(this.mesh).getSize(new THREE.Vector3()).length() || 1;
                const pushOut = Math.max(1e-4, diag * 0.1);

                const chosen = [];
                const maxInstances = this.disks.count;
                const tmpN = new THREE.Vector3();

                for (let row = 0, v = vmin; v <= vmax; row++, v += dv) {
                    const uOffset = (row % 2) ? du * 0.5 : 0;
                    for (let u = umin + uOffset; u <= umax; u += du) {
                        const origin = center.clone().addScaledVector(U, u).addScaledVector(V, v).addScaledVector(normal, pushOut);
                        raycaster.set(origin, normal.clone().multiplyScalar(-1));
                        const hit = raycaster.intersectObject(targetMesh, false)[0];
                        if (hit) {
                            tmpN.copy(hit.face.normal).transformDirection(targetMesh.matrixWorld).normalize();
                            chosen.push({ pos: hit.point.clone(), nrm: tmpN.clone() });
                            if (chosen.length >= maxInstances) break;
                        }
                    }
                    if (chosen.length >= maxInstances) break;
                }

                targetMesh.geometry.disposeBoundsTree();
                targetMesh.geometry.dispose();
                this.finalPoints = chosen;
                this.updateInstances();

                console.timeEnd('Hex Grid Generation');
                document.getElementById('info').innerHTML =
                    `✅ 六角网格 | 间距=${this.spacing.toFixed(4)} | 点数 <span class="num">${chosen.length}</span>`;
            }

            updateInstances() {
                const count = this.finalPoints.length;
                const bbox = new THREE.Box3().setFromObject(this.mesh);

                this.attrInt.array.fill(0);
                const colArr = this.attrCol.array;
                const nrmArr = this.disks.geometry.getAttribute('nrmW').array;
                for (let i = 0; i < count; i++) {
                    colArr.set([0.1, 0.85, 0.6], i * 3);
                    this.finalPoints[i].nrm.toArray(nrmArr, i * 3);
                }

                const M = new THREE.Matrix4();
                const radii = this.disks.geometry.getAttribute('radius').array;
                const baseR = this.spacing * 0.28;
                this.matDisks.uniforms.pushW.value = this.spacing * 0.3;

                for (let i = 0; i < count; i++) {
                    M.makeTranslation(this.finalPoints[i].pos.x, this.finalPoints[i].pos.y, this.finalPoints[i].pos.z);
                    this.disks.setMatrixAt(i, M);
                    radii[i] = baseR;
                }
                for (let i = count; i < radii.length; i++) radii[i] = 0;

                this.disks.count = count;
                this.disks.instanceMatrix.needsUpdate = true;
                this.disks.geometry.getAttribute('radius').needsUpdate = true;
                this.disks.geometry.getAttribute('nrmW').needsUpdate = true;
                this.disks.geometry.getAttribute('color').needsUpdate = true;
                this._center = bbox.getCenter(new THREE.Vector3());
            }
        }

        let tactile = null;
        let current = null, aligner = null, mixer = null;
        const loader = new GLTFLoader();
        loader.setDRACOLoader(new DRACOLoader().setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/'));
        loader.setMeshoptDecoder(MeshoptDecoder);

        async function loadURL(url, name = '模型') {
            document.getElementById('info').textContent = `加载中：${name} ...`;
            try {
                if (tactile) tactile.dispose();
                if (aligner) scene.remove(aligner);

                const gltf = await loader.loadAsync(url);
                current = gltf.scene;

                aligner = new THREE.Group();
                scene.add(aligner);
                aligner.add(current);
                mapAxes(aligner, { x: '-x', y: '-y', z: '+z' });
                aligner.updateWorldMatrix(true, true);

                mixer = null;
                if (gltf.animations?.length) {
                    mixer = new THREE.AnimationMixer(current);
                    mixer.clipAction(gltf.animations[0]).play();
                }

                const touchArea = current.getObjectByName('touch_area');
                if (touchArea) {
                    touchArea.traverse(o => {
                        if (o.isMesh) {
                            o.material = o.material.clone();
                            o.material.transparent = true;
                            o.material.opacity = 0.0;
                        }
                    });
                }
                const target = touchArea || current;

                frameToObject(aligner);

                const modelSize = new THREE.Box3().setFromObject(aligner).getSize(new THREE.Vector3()).length();
                tactile = new TactileLayer(target, { spacing: modelSize / 70, maxPoints: 8000 });
                await tactile.generateHexGrid(camera);

                const tris = renderer.info.render.triangles;
                document.getElementById('info').innerHTML = `✅ 已加载：<span class="num">${name}</span>`;
                document.getElementById('stats').innerHTML = `三角面 <span class="num">${tris.toLocaleString()}</span>`;

                resetView();
            } catch (e) {
                console.error(e);
                document.getElementById('info').textContent = `❌ 加载失败：${e.message || e}`;
            }
        }

        function resize() {
            const rect = wrap.getBoundingClientRect();
            const w = Math.max(1, rect.width);
            const h = Math.max(1, rect.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(w, h, false);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            controls.update();
        }

        function resetView() {
            if (aligner) frameToObject(aligner);
        }

        function frameToObject(obj, padding = 1.15) {
            const box = new THREE.Box3().setFromObject(obj);
            const sphere = box.getBoundingSphere(new THREE.Sphere());
            const center = sphere.center;
            const radius = Math.max(1e-6, sphere.radius);
            const vFov = camera.fov * Math.PI / 180;
            const hFov = 2 * Math.atan(Math.tan(vFov * 0.5) * camera.aspect);
            const fov = Math.min(vFov, hFov);
            const dist = radius / Math.sin(fov * 0.5) * padding;
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            let dir;
            if (maxDim === size.y) dir = new THREE.Vector3(0.8, 0.4, 0.8);
            else if (maxDim === size.x) dir = new THREE.Vector3(0.6, 0.6, 1);
            else dir = new THREE.Vector3(1, 0.6, 1);
            camera.position.copy(center).addScaledVector(dir.normalize(), dist);
            camera.near = Math.max(dist - radius * 3, 0.001);
            camera.far = dist + radius * 10;
            camera.updateProjectionMatrix();
            controls.target.copy(center);
            controls.update();
        }

        function mapAxes(obj, map) {
            const pick = s => {
                switch (s) {
                    case '+x': return new THREE.Vector3(1, 0, 0);
                    case '-x': return new THREE.Vector3(-1, 0, 0);
                    case '+y': return new THREE.Vector3(0, 1, 0);
                    case '-y': return new THREE.Vector3(0, -1, 0);
                    case '+z': return new THREE.Vector3(0, 0, 1);
                    case '-z': return new THREE.Vector3(0, 0, -1);
                    default: return new THREE.Vector3(1, 0, 0);
                }
            };
            const Xw = pick(map.x), Yw = pick(map.y), Zw = pick(map.z);
            const m = new THREE.Matrix4().makeBasis(Xw, Yw, Zw);
            obj.setRotationFromQuaternion(new THREE.Quaternion().setFromRotationMatrix(m));
        }

        new ResizeObserver(resize).observe(wrap);
        resize();

        const fileInput = document.getElementById('file');
        fileInput.addEventListener('change', () => {
            const f = fileInput.files[0]; if (!f) return; loadURL(URL.createObjectURL(f), f.name);
        });
        document.getElementById('btnResample').addEventListener('click', async () => {
            if (!current || !tactile) return;
            await tactile.generateHexGrid(camera);
        });
        document.getElementById('btnReset').addEventListener('click', resetView);
        document.getElementById('chkAuto').addEventListener('change', e => { controls.autoRotate = e.target.checked; });
        document.getElementById('chkBg').addEventListener('change', e => {
            scene.background.set(e.target.checked ? 0x0b0b0b : 0xf8fafc);
            grid.visible = !e.target.checked;
        });

        const clock = new THREE.Clock();
        (function animate() {
            requestAnimationFrame(animate);
            controls.update();
            mixer?.update(clock.getDelta());
            if (tactile?.running) {
                tactile.matDisks.uniforms.camRight.value.setFromMatrixColumn(camera.matrixWorld, 0);
                tactile.matDisks.uniforms.camUp.value.setFromMatrixColumn(camera.matrixWorld, 1);
            }
            renderer.render(scene, camera);
        })();
    </script>
</body>

</html>